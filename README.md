# 시스템 부하 및 CPU 상태 모니터링

## 1. 시스템 부하 확인 (`uptime` 명령어)

```bash
user07@servername:~$ uptime
03:21:18 up  7:17,  7 users,  load average: 0.18, 0.27, 0.30
```
시스템 부하 평균 (Load Average):
- 0.18: 지난 1분 동안의 평균 부하
- 0.27: 지난 5분 동안의 평균 부하
- 0.30: 지난 15분 동안의 평균 부하

- 부하 평균은 CPU가 얼마나 사용되고 있는지, 또는 얼마나 대기 중인지 보여주는 지표입니다. 1.00은 단일 CPU 시스템에서 CPU가 100% 사용 중이라는 것을 의미하며, 여러 CPU가 있는 시스템에서는 CPU 수에 맞춰 해석해야 합니다.

## 2. 평균 부하란?
평균 부하는 단위 시간당 활성 상태인 프로세스 수를 나타냅니다. 즉, CPU가 실행 중이거나 CPU를 기다리고 있는 프로세스들의 평균 수치를 보여줍니다. 평균 부하는 1분, 5분, 15분 동안의 수치를 기록하며 시스템의 최근 부하 상황을 파악할 수 있습니다.

## 3.CPU 코어 수에 따른 부하 해석
CPU가 2개 있는 시스템: 평균 부하가 2라면, 모든 CPU가 완전히 사용 중이라는 뜻입니다.
CPU가 4개 있는 시스템: 평균 부하가 2라면, 시스템에 50%의 여유가 있음을 의미합니다.
CPU가 1개 있는 시스템: 평균 부하가 2라면, 시스템이 과부하 상태에 있으며, CPU는 여러 작업을 처리하느라 대기 중인 상태입니다.
코어수 확인
```bash
 grep 'model name' /proc/cpuinfo | wc -l
```
![image](https://github.com/user-attachments/assets/52cb3297-378c-4a7e-8294-d37497b0e4e4)


## 4. 적절한 평균 부하

CPU 코어 수와 일치하는 평균 부하는 시스템이 최적 상태로 작동하고 있음을 의미합니다. 예를 들어, CPU가 4개인 시스템에서 평균 부하가 **4.00**이라면 CPU가 100% 활용되고 있는 상태입니다. 평균 부하가 이 값을 넘으면 시스템은 과부하 상태에 있을 수 있습니다.

제 생각에는 평균 부하가 CPU 수의 **70%**를 초과하면 고부하 문제를 분석하고 조사해야 합니다. 고부하는 프로세스 응답 속도를 늦추어 서비스의 정상적인 작동에 영향을 미칠 수 있습니다.

그러나 70% 수치는 절대적인 것이 아닙니다. 권장되는 접근 방식은 평균 시스템 부하를 모니터링하고 더 많은 과거 데이터를 기반으로 부하 추세를 판단하는 것입니다. 부하가 두 배로 증가하는 등 부하가 상당히 증가한 것을 발견하면 분석하고 조사할 때입니다.

## 5. 시스템 부하 분석 및 사례 연구

### 시스템 구성

- **CPU**: 2개
- **RAM**: 8GB
- **사전 설치 패키지**: `stress`, `sysstat` (설치 명령: `apt install stress sysstat`)

### 평균 부하 및 CPU 사용량

#### 1. 평균 부하 (Load Average)
평균 부하는 시스템에서 활성 프로세스의 수를 나타냅니다. 여기에는 CPU를 사용 중인 프로세스, CPU 시간을 기다리는 프로세스, 그리고 **I/O(입출력)** 작업을 기다리는 프로세스도 포함됩니다.  
즉, 단순히 CPU 사용량만이 아닌 대기 중인 프로세스의 수까지 반영합니다.

#### 2. CPU 사용량 (CPU Usage)
CPU 사용량은 단위 시간 동안 CPU가 얼마나 바쁜지를 나타냅니다. 이는 CPU가 작업을 처리하는 데 사용한 실제 시간을 의미하며, 보통 **100%**를 기준으로 측정됩니다.  
높은 CPU 사용량은 CPU가 매우 바쁘게 일하고 있다는 신호입니다.

#### 3. 두 지표의 차이
- **CPU 집약적인 작업**: CPU를 많이 사용하는 경우, 평균 부하와 CPU 사용량은 함께 증가합니다.
- **I/O 바인딩 작업**: I/O 작업 대기 시 평균 부하는 증가하지만 CPU는 덜 바쁠 수 있어 CPU 사용량은 낮을 수 있습니다.
- **CPU 스케줄링 대기 작업**: 많은 프로세스가 CPU 스케줄링을 기다리는 경우, 평균 부하와 CPU 사용량이 동시에 높을 수 있습니다.

### 사례 연구: 평균 부하 증가 시나리오
---
### 시나리오1: CPU 집약적 작업

이 실험을 통해 CPU에 부하가 걸렸을 때 시스템의 반응을 모니터링하고, 성능 변화를 확인할 수 있습니다.

---
##### 1. 첫 번째 터미널에서 stress 명령어를 사용하여 CPU 사용률을 100%로 만드는 상황을 시뮬레이션합니다
```bash
stress --cpu 1 --timeout 600
```
이 명령어는 600초(10분) 동안 CPU 코어 1개를 100%로 사용하게 만듭니다.
![image](https://github.com/user-attachments/assets/8721df1c-d2ca-40b0-a36e-4c03cf29ce95)

##### 2. 두 번째 터미널에서는 uptime 명령어를 사용하여 평균 부하(Load Average)의 변화를 확인합니다
```bash
uptime
```
uptime 명령어를 실행하면 최근 1분, 5분, 15분 동안의 평균 부하를 보여주며, 이 값을 통해 시스템이 얼마나 바쁘게 일하고 있는지 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/097b4795-2faf-4b46-a0cf-d597f766a1d7)

##### 3. **세 번째 터미널**에서는 `mpstat`나 `pidstat` 같은 도구를 사용하여 구체적으로 각 CPU 코어의 성능을 모니터링할 수 있습니다.
![image](https://github.com/user-attachments/assets/53193438-000d-47de-aa9d-0aa677cde54f)

CPU 집약적인 작업이 시작되면 CPU 사용률이 급격히 증가하고, 이에 따라 평균 부하가 1 이상으로 증가할 것입니다. 특히 단일 CPU에서는 이 값이 1을 초과하면 과부하 상태임을 나타냅니다


---

### 시나리오 2: I/O 집약적 프로세스 분석

이 시나리오는 **I/O 작업이 시스템 부하에 미치는 영향을 분석**하기 위한 실험입니다. 여기서는 **`stress`** 명령어를 사용하여 I/O 작업을 시뮬레이션하고, 시스템 부하와 CPU 사용량을 실시간으로 모니터링합니다.

---

##### 1. **I/O 작업 시뮬레이션**

```bash
stress -i 1 --timeout 600
```
1개의 I/O 집약적 작업을 실행하여 시스템에 I/O 부하를 가합니다. 이 작업은 600초(10분) 동안 지속됩니다.

##### 2. **부하 모니터링 (`uptime`)**

```bash
watch -d uptime
```

- **`watch -d uptime`**: 매초 `uptime` 명령어를 실행하여 시스템 부하를 실시간으로 모니터링하고, 부하가 어떻게 변화하는지 확인합니다. `d` 옵션은 **변경된 부분을 강조**하여 보여줍니다.

이 부하 값은 CPU와 I/O 작업이 시스템에 주는 영향을 실시간으로 모니터링할 수 있는 지표입니다. I/O 작업이 많아질수록, 시스템 부하 값도 증가할 수 있습니다.
![image](https://github.com/user-attachments/assets/859159eb-7f89-49ea-9245-105fea7cccad)

![image](https://github.com/user-attachments/assets/f5fb512c-867e-42bd-8bd9-0ef456f5961b)

- **%iowait**가 높다는 것은 CPU가 입출력(I/O) 작업을 기다리며 상당 부분 유휴 상태에 있음을 나타냅니다. 특히 CPU 0이 I/O 대기를 많이 하고 있으며, CPU 사용률 자체는 낮지만, 시스템 입출력 성능이 현재 병목 상태에 있을 가능성이 있습니다.
- **%idle** 값이 높다는 것은 CPU가 실제로 많이 사용되고 있지 않다는 것을 의미하지만, **I/O 대기 시간(%iowait)**이 높아 성능 저하를 일으킬 수 있습니다.

이를 통해 **입출력 대기 시간이 길어지는 문제**를 발견하고, 성능을 최적화하기 위한 추가 분석과 조치(예: I/O 병목 현상 해결, 디스크 성능 최적화)를 고려해야 할 수 있습니다.

---
### 시나리오3: **프로세스 수가 많은 시나리오**
---
##### 1. **8개의 CPU 집약적 프로세스 실행**
```bash
stress -c 8 --timeout 600
```
![image](https://github.com/user-attachments/assets/56ce156b-ac8d-46f1-a605-7bb4c0a00409)
- **`uptime` 부하 모니터링**:
    - 부하 평균이 **7.28**로, CPU가 감당할 수 있는 범위를 넘어섰음을 보여줍니다. **과부하 상태**에서 CPU가 처리할 수 있는 프로세스보다 더 많은 작업이 대기하고 있습니다.
- **`pidstat`로 프로세스 모니터링**:
    - **`stress` 프로세스**들이 CPU의 75%를 차지하며, 각 프로세스가 CPU 리소스를 놓고 **경쟁**하고 있습니다.
    - **`%wait` 값**이 74.80%까지 올라간 것을 확인할 수 있으며, 이는 CPU가 처리하지 못해 많은 프로세스가 대기 중임을 의미합니다.
 
![image](https://github.com/user-attachments/assets/32a8ac31-298b-47dc-a4e3-1b1e9cc28f80)
##### 2. 프로세스별 CPU 사용 분석

1. **%CPU 값 확인**:
    - **`stress`** 프로세스들이 차지하는 CPU 비율은 **%CPU** 열에서 확인할 수 있습니다.
    - 예시에서 **각 `stress` 프로세스**는 **0.06% ~ 0.11%**의 CPU 사용률을 보이고 있습니다.
2. **프로세스가 차지하는 총 CPU 비율 계산**:
    - `stress` 프로세스가 총 8개가 실행 중입니다.
    - 각 `stress` 프로세스의 CPU 사용량을 합산하여 시스템 전체에서 CPU 리소스를 얼마나 많이 차지하고 있는지 확인할 수 있습니다.
    - 만약 모든 `stress` 프로세스가 약 **10~11%**의 CPU를 사용하고 있다면, 8개의 프로세스가 약 **80%**의 CPU 자원을 소모하고 있음을 알 수 있습니다.

따라서, 여러 `stress` 프로세스들이 병렬로 실행되면서 CPU의 리소스를 거의 **75% 이상** 사용하고 있다고 추정할 수 있습니다.
